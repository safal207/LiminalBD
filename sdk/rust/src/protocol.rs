// This file is auto-generated by protocol/codegen.rs. Do not edit.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize)]
pub struct AuthCommand {
    #[serde(rename = "keyId")]
    pub key_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    pub op: String,
    pub secret: String
}

#[derive(Debug, Clone, Serialize)]
pub struct AwakenNowCommand {
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub struct DreamNowCommand {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub intensity: Option<f64>,
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub struct IntentInvokeCommand {
    pub kind: String,
    pub op: String,
    pub payload: serde_json::Value
}

#[derive(Debug, Clone, Serialize)]
pub struct IntentTextCommand {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lang: Option<String>,
    pub op: String,
    pub text: String
}

#[derive(Debug, Clone, Serialize)]
pub struct LqlCommand {
    pub id: String,
    pub op: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    pub query: String
}

#[derive(Debug, Clone, Serialize)]
pub struct MirrorReplayCommand {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cursor: Option<String>,
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub struct MirrorTimelineCommand {
    pub op: String,
    pub range: serde_json::Value
}

#[derive(Debug, Clone, Serialize)]
pub struct NoeticPeersCommand {
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub struct NoeticProposeCommand {
    pub op: String,
    pub proposal: serde_json::Value
}

#[derive(Debug, Clone, Serialize)]
pub struct PeerAddCommand {
    pub op: String,
    pub peer: serde_json::Value
}

#[derive(Debug, Clone, Serialize)]
pub struct PeerListCommand {
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub struct QuotaCommand {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub struct SeedAbortCommand {
    pub id: String,
    pub op: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>
}

#[derive(Debug, Clone, Serialize)]
pub struct SeedGardenCommand {
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub struct SeedPlantCommand {
    pub id: String,
    pub op: String,
    pub spec: serde_json::Value
}

#[derive(Debug, Clone, Serialize)]
pub struct SnapshotCommand {
    pub op: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>
}

#[derive(Debug, Clone, Serialize)]
pub struct SubscribeCommand {
    pub id: String,
    pub op: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<serde_json::Value>,
    pub pattern: String
}

#[derive(Debug, Clone, Serialize)]
pub struct SyncNowCommand {
    pub op: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>
}

#[derive(Debug, Clone, Serialize)]
pub struct UnsubscribeCommand {
    pub id: String,
    pub op: String
}

#[derive(Debug, Clone, Serialize)]
pub enum CommandEnvelope {
    AuthCommand(AuthCommand),
    AwakenNowCommand(AwakenNowCommand),
    DreamNowCommand(DreamNowCommand),
    IntentInvokeCommand(IntentInvokeCommand),
    IntentTextCommand(IntentTextCommand),
    LqlCommand(LqlCommand),
    MirrorReplayCommand(MirrorReplayCommand),
    MirrorTimelineCommand(MirrorTimelineCommand),
    NoeticPeersCommand(NoeticPeersCommand),
    NoeticProposeCommand(NoeticProposeCommand),
    PeerAddCommand(PeerAddCommand),
    PeerListCommand(PeerListCommand),
    QuotaCommand(QuotaCommand),
    SeedAbortCommand(SeedAbortCommand),
    SeedGardenCommand(SeedGardenCommand),
    SeedPlantCommand(SeedPlantCommand),
    SnapshotCommand(SnapshotCommand),
    SubscribeCommand(SubscribeCommand),
    SyncNowCommand(SyncNowCommand),
    UnsubscribeCommand(UnsubscribeCommand),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertEvent {
    pub kind: String,
    pub message: String,
    pub severity: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditEvent {
    pub action: String,
    pub actor: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details: Option<serde_json::Value>,
    pub kind: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AwakenEvent {
    pub kind: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BaseEvent {
    #[serde(rename = "correlationId")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation_id: Option<String>,
    pub id: String,
    pub ts: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollectiveDreamEvent {
    pub kind: String,
    pub members: Vec<String>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DreamEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details: Option<serde_json::Value>,
    pub kind: String,
    pub phase: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EchoEvent {
    pub kind: String,
    pub status: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExplainEvent {
    pub explanation: String,
    pub kind: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HarmonyEvent {
    pub kind: String,
    pub score: f64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trend: Option<String>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LqlEvent {
    pub kind: String,
    pub result: Vec<serde_json::Value>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MirrorEvent {
    pub entries: Vec<serde_json::Value>,
    pub kind: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NoeticEvent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<serde_json::Value>,
    pub kind: String,
    pub stage: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SeedEvent {
    pub kind: String,
    pub status: String,
    #[serde(rename = "yield")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub r#yield: Option<serde_json::Value>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatusEvent {
    pub kind: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<serde_json::Value>,
    pub state: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewEvent {
    pub kind: String,
    pub payload: serde_json::Value,
    pub stream: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EventEnvelope {
    AlertEvent(AlertEvent),
    AuditEvent(AuditEvent),
    AwakenEvent(AwakenEvent),
    BaseEvent(BaseEvent),
    CollectiveDreamEvent(CollectiveDreamEvent),
    DreamEvent(DreamEvent),
    EchoEvent(EchoEvent),
    ExplainEvent(ExplainEvent),
    HarmonyEvent(HarmonyEvent),
    LqlEvent(LqlEvent),
    MirrorEvent(MirrorEvent),
    NoeticEvent(NoeticEvent),
    SeedEvent(SeedEvent),
    StatusEvent(StatusEvent),
    ViewEvent(ViewEvent),
}

