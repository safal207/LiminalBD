use std::collections::BTreeMap;
use std::fs;
use std::path::PathBuf;

use anyhow::Context;
use heck::ToSnakeCase;
use serde::Deserialize;
use serde_json::Value;

#[derive(Debug, Deserialize)]
struct SchemaBundle {
    definitions: BTreeMap<String, Schema>,
}

#[derive(Debug, Deserialize, Clone)]
struct Schema {
    #[serde(default)]
    title: Option<String>,
    #[serde(default)]
    r#type: Option<String>,
    #[serde(default)]
    properties: BTreeMap<String, Value>,
    #[serde(default)]
    required: Vec<String>,
    #[serde(default, rename = "allOf")]
    all_of: Vec<Schema>,
}

pub fn generate() -> anyhow::Result<()> {
    let manifest_dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR")?);
    let root = manifest_dir.parent().context("missing protocol parent")?.to_path_buf();
    let schema_dir = manifest_dir.join("schemas");

    let commands: SchemaBundle = serde_json::from_str(&fs::read_to_string(schema_dir.join("commands.json"))?)?;
    let events: SchemaBundle = serde_json::from_str(&fs::read_to_string(schema_dir.join("events.json"))?)?;

    let mut out = String::new();
    out.push_str("// This file is auto-generated by protocol/codegen.rs. Do not edit.\n\nuse serde::{Deserialize, Serialize};\n\n");

    let mut command_names: Vec<_> = commands.definitions.keys().cloned().collect();
    command_names.sort();
    for name in &command_names {
        out.push_str(&render_struct(name, &commands.definitions[name], false));
        out.push('\n');
    }
    out.push_str(&render_enum("CommandEnvelope", &command_names, false));
    out.push('\n');

    let mut event_names: Vec<_> = events.definitions.keys().cloned().collect();
    event_names.sort();
    for name in &event_names {
        out.push_str(&render_struct(name, &events.definitions[name], true));
        out.push('\n');
    }
    out.push_str(&render_enum("EventEnvelope", &event_names, true));
    out.push('\n');

    let output = root.join("sdk").join("rust").join("src").join("protocol.rs");
    if let Some(parent) = output.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(output, out)?;

    Ok(())
}

fn render_struct(name: &str, schema: &Schema, derive_deserialize: bool) -> String {
    let merged = merge_schema(schema);
    let mut fields = Vec::new();
    for (key, value) in &merged.properties {
        let ty = type_for_property(value);
        let (field_name, rename_attr) = rust_identifier(key);
        let mut attrs = Vec::new();
        if let Some(original) = rename_attr {
            attrs.push(format!("    #[serde(rename = \"{}\")]", original));
        }
        let field = if merged.required.contains(key) {
            if attrs.is_empty() {
                format!("    pub {}: {}", field_name, ty)
            } else {
                format!("{}\n    pub {}: {}", attrs.join("\n"), field_name, ty)
            }
        } else {
            attrs.push("    #[serde(default, skip_serializing_if = \"Option::is_none\")]".to_string());
            format!(
                "{}\n    pub {}: Option<{}>",
                attrs.join("\n"),
                field_name,
                ty
            )
        };
        fields.push(field);
    }

    let derives = if derive_deserialize {
        "#[derive(Debug, Clone, Serialize, Deserialize)]"
    } else {
        "#[derive(Debug, Clone, Serialize)]"
    };
    let body = fields.join(",\n");
    if body.is_empty() {
        format!("{}\npub struct {} {{}}\n", derives, name)
    } else {
        format!("{}\npub struct {} {{\n{}\n}}\n", derives, name, body)
    }
}

fn render_enum(name: &str, members: &[String], derive_deserialize: bool) -> String {
    let variants = members
        .iter()
        .map(|member| format!("    {}({}),", member, member))
        .collect::<Vec<_>>()
        .join("\n");
    let derives = if derive_deserialize {
        "#[derive(Debug, Clone, Serialize, Deserialize)]"
    } else {
        "#[derive(Debug, Clone, Serialize)]"
    };
    format!(
        "{}\npub enum {} {{\n{}\n}}\n",
        derives,
        name,
        variants
    )
}

fn type_for_property(value: &Value) -> String {
    if value.get("const").is_some() || value.get("enum").is_some() {
        return "String".into();
    }
    match value.get("type").and_then(|v| v.as_str()) {
        Some("string") => "String".into(),
        Some("integer") => "i64".into(),
        Some("number") => "f64".into(),
        Some("boolean") => "bool".into(),
        Some("array") => {
            let item_ty = value
                .get("items")
                .map(type_for_property)
                .unwrap_or_else(|| "serde_json::Value".into());
            format!("Vec<{}>", item_ty)
        }
        Some("object") => "serde_json::Value".into(),
        _ => "serde_json::Value".into(),
    }
}

fn merge_schema(schema: &Schema) -> Schema {
    let mut combined = Schema {
        title: schema.title.clone(),
        r#type: schema.r#type.clone(),
        properties: schema.properties.clone(),
        required: schema.required.clone(),
        all_of: Vec::new(),
    };
    for part in &schema.all_of {
        let inner = merge_schema(part);
        for (key, value) in inner.properties {
            combined.properties.insert(key, value);
        }
        for req in inner.required {
            if !combined.required.contains(&req) {
                combined.required.push(req);
            }
        }
    }
    combined
}

fn rust_identifier(name: &str) -> (String, Option<String>) {
    let mut ident = name.to_snake_case();
    if ident.is_empty() {
        ident.push('_');
    }

    let mut sanitized = String::new();
    for (idx, ch) in ident.chars().enumerate() {
        if idx == 0 {
            if ch.is_ascii_alphabetic() || ch == '_' {
                sanitized.push(ch);
            } else {
                sanitized.push('_');
                if ch.is_ascii_alphanumeric() {
                    sanitized.push(ch);
                }
            }
        } else if ch.is_ascii_alphanumeric() || ch == '_' {
            sanitized.push(ch);
        } else if !sanitized.ends_with('_') {
            sanitized.push('_');
        }
    }
    if sanitized.is_empty() {
        sanitized.push('_');
    }

    let keywords = [
        "as", "break", "const", "continue", "crate", "else", "enum", "extern", "false", "fn",
        "for", "if", "impl", "in", "let", "loop", "match", "mod", "move", "mut",
        "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait", "true",
        "type", "unsafe", "use", "where", "while", "async", "await", "dyn", "abstract", "become",
        "box", "do", "final", "macro", "override", "priv", "try", "typeof", "unsized", "virtual",
        "yield",
    ];
    if keywords.contains(&sanitized.as_str()) {
        sanitized = format!("r#{}", sanitized);
    }
    if sanitized == name {
        (sanitized, None)
    } else {
        (sanitized, Some(name.to_string()))
    }
}
