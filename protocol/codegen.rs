use std::collections::BTreeMap;
use std::fs;
use std::path::Path;

use serde::Deserialize;
use serde_json::Value;

#[derive(Debug, Deserialize)]
struct SchemaBundle {
    definitions: BTreeMap<String, Schema>,
}

#[derive(Debug, Deserialize)]
struct Schema {
    #[serde(default)]
    title: Option<String>,
    #[serde(default)]
    r#type: Option<String>,
    #[serde(default)]
    properties: BTreeMap<String, Value>,
    #[serde(default)]
    required: Vec<String>,
    #[serde(default)]
    allOf: Vec<Schema>,
    #[serde(default)]
    r#const: Option<Value>,
    #[serde(default)]
    r#enum: Option<Vec<Value>>,
}

fn type_for_property(value: &Value) -> String {
    if let Some(c) = value.get("const") {
        return format_literal(c);
    }
    if let Some(en) = value.get("enum") {
        if let Some(arr) = en.as_array() {
            let parts: Vec<String> = arr.iter().map(format_literal).collect();
            return parts.join(" | ");
        }
    }
    match value.get("type").and_then(|v| v.as_str()) {
        Some("string") => "String".into(),
        Some("integer") => "i64".into(),
        Some("number") => "f64".into(),
        Some("boolean") => "bool".into(),
        Some("array") => {
            let item_ty = value
                .get("items")
                .map(type_for_property)
                .unwrap_or_else(|| "serde_json::Value".into());
            format!("Vec<{}>", item_ty)
        }
        Some("object") => {
            if value.get("properties").is_none() || value.get("additionalProperties").is_some() {
                "serde_json::Value".into()
            } else {
                "serde_json::Value".into()
            }
        }
        _ => "serde_json::Value".into(),
    }
}

fn format_literal(value: &Value) -> String {
    match value {
        Value::String(s) => format!("\"{}\"", s),
        Value::Number(n) => n.to_string(),
        Value::Bool(b) => b.to_string(),
        _ => "serde_json::Value".into(),
    }
}

fn render_struct(name: &str, schema: &Schema) -> String {
    if !schema.allOf.is_empty() {
        let parts: Vec<String> = schema
            .allOf
            .iter()
            .enumerate()
            .map(|(idx, part)| format!("{}Part{}", name, idx))
            .collect();
        let mut out = String::new();
        for (idx, part) in schema.allOf.iter().enumerate() {
            out.push_str(&render_struct(&format!("{}Part{}", name, idx), part));
            out.push_str("\n");
        }
        out.push_str(&format!("#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct {} {{\n    #[serde(flatten)]\n    pub inner: ({})\n}}\n", name, parts.join(", ")));
        return out;
    }

    let mut fields = Vec::new();
    for (key, value) in &schema.properties {
        let ty = type_for_property(value);
        let optional = !schema.required.contains(key);
        if optional {
            fields.push(format!("    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub {}: Option<{}>", key, ty));
        } else {
            fields.push(format!("    pub {}: {}", key, ty));
        }
    }

    format!(
        "#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct {} {{\n{}\n}}\n",
        name,
        fields.join(";\n")
    )
}

fn render_enum(name: &str, members: &[String]) -> String {
    let variants: Vec<String> = members
        .iter()
        .map(|member| format!("    {}({}),", member, member))
        .collect();
    format!(
        "#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub enum {} {{\n{}\n}}\n",
        name,
        variants.join("\n")
    )
}

fn main() -> anyhow::Result<()> {
    let root = Path::new(env!("CARGO_MANIFEST_DIR")).join("..");
    let schema_dir = root.join("schemas");
    let commands: SchemaBundle = serde_json::from_str(&fs::read_to_string(schema_dir.join("commands.json"))?)?;
    let events: SchemaBundle = serde_json::from_str(&fs::read_to_string(schema_dir.join("events.json"))?)?;

    let mut out = String::new();
    out.push_str("// This file is auto-generated by protocol/codegen.rs. Do not edit.\n\n");

    let mut command_names: Vec<String> = commands.definitions.keys().cloned().collect();
    command_names.sort();
    for name in &command_names {
        out.push_str(&render_struct(name, &commands.definitions[name]));
        out.push_str("\n");
    }
    out.push_str(&render_enum("CommandEnvelope", &command_names));
    out.push_str("\n");

    let mut event_names: Vec<String> = events.definitions.keys().cloned().collect();
    event_names.sort();
    for name in &event_names {
        out.push_str(&render_struct(name, &events.definitions[name]));
        out.push_str("\n");
    }
    out.push_str(&render_enum("EventEnvelope", &event_names));
    out.push_str("\n");

    let out_path = root.join("sdk").join("rust").join("src").join("protocol.rs");
    fs::create_dir_all(out_path.parent().unwrap())?;
    fs::write(out_path, out)?;

    Ok(())
}
