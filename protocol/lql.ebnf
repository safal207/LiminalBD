(* Liminal Query Language v1 grammar (subset) *)
query         = ws , (selectStmt | insertStmt | updateStmt | deleteStmt) , ws ;
selectStmt    = "SELECT" , ws1 , projection , ws , "FROM" , ws1 , source , [ ws , whereClause ] , [ ws , limitClause ] ;
projection    = "*" | columnList ;
columnList    = column , { ws? , "," , ws? , column } ;
column        = identifier , [ ws , "AS" , ws1 , identifier ] ;
source        = identifier , [ ws , "AS" , ws1 , identifier ] ;
whereClause   = "WHERE" , ws1 , expression ;
limitClause   = "LIMIT" , ws1 , number , [ ws , "OFFSET" , ws1 , number ] ;
expression    = orExpr ;
orExpr        = andExpr , { ws , "OR" , ws , andExpr } ;
andExpr       = notExpr , { ws , "AND" , ws , notExpr } ;
notExpr       = [ "NOT" , ws1 ] , comparison ;
comparison    = additive , [ ws , comparator , ws , additive ] ;
additive      = multiplicative , { ws , ("+" | "-") , ws , multiplicative } ;
multiplicative = unary , { ws , ("*" | "/") , ws , unary } ;
unary         = [ ("+" | "-") , ws ] , primary ;
primary       = literal | identifier | functionCall | "(" , ws? , expression , ws? , ")" ;
functionCall  = identifier , ws? , "(" , ws? , [ argumentList ] , ws? , ")" ;
argumentList  = expression , { ws? , "," , ws? , expression } ;
identifier    = identStart , { identContinue } ;
identStart    = letter | "_" ;
identContinue = identStart | digit ;
literal       = stringLiteral | number | boolean | nullLiteral ;
stringLiteral = "'" , { character - "'" } , "'" ;
number        = digit , { digit } , [ "." , digit , { digit } ] ;
boolean       = "TRUE" | "FALSE" ;
nullLiteral   = "NULL" ;
letter        = "A".."Z" | "a".."z" ;
digit         = "0".."9" ;
ws            = { " " | "\t" | "\n" | "\r" } ;
ws1           = ws , { ws } ;
