import { promises as fs } from 'node:fs';
import path from 'node:path';

const ROOT = path.dirname(new URL(import.meta.url).pathname);
const SCHEMA_DIR = path.join(ROOT, 'schemas');
const OUTPUT_TS = path.join(ROOT, '..', 'sdk', 'ts', 'src', 'protocol-types.ts');

function typeForProperty(property) {
  if (property.const !== undefined) {
    return JSON.stringify(property.const);
  }
  if (property.enum) {
    return property.enum.map((v) => JSON.stringify(v)).join(' | ');
  }
  switch (property.type) {
    case 'string':
      return 'string';
    case 'integer':
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      return `${typeForProperty(property.items ?? { type: 'unknown' })}[]`;
    case 'object': {
      const props = property.properties ?? {};
      const keys = Object.keys(props);
      if (keys.length === 0 || property.additionalProperties) {
        return 'Record<string, unknown>';
      }
     const fields = keys
       .map((key) => {
          const requiredKeys = new Set(property.required ?? []);
          const optional = !requiredKeys.has(key);
          return `  ${JSON.stringify(key)}${optional ? '?' : ''}: ${typeForProperty(props[key])};`;
        })
        .join('\n');
      return `{\n${fields}\n}`;
    }
    default:
      return 'unknown';
  }
}

function renderInterface(name, schema) {
  if (schema.allOf) {
    return `export type ${name} = ${schema.allOf
      .map((part) => renderAnonymousType(part))
      .join(' & ')};`;
  }
  return `export interface ${name} ${renderAnonymousType(schema)};`;
}

function renderAnonymousType(schema) {
  const props = schema.properties ?? {};
  const required = new Set(schema.required ?? []);
  const entries = Object.entries(props).map(([key, prop]) => {
    const optional = !required.has(key);
    return `  ${JSON.stringify(key)}${optional ? '?' : ''}: ${typeForProperty(prop)};`;
  });
  return `{\n${entries.join('\n')}\n}`;
}

function renderUnion(name, members) {
  return `export type ${name} = ${members.join(' | ')};`;
}

async function loadSchema(name) {
  const file = path.join(SCHEMA_DIR, `${name}.json`);
  const data = await fs.readFile(file, 'utf8');
  return JSON.parse(data);
}

async function generateTypes() {
  const [commands, events] = await Promise.all([
    loadSchema('commands'),
    loadSchema('events'),
  ]);

  const lines = [
    '// This file is auto-generated by protocol/codegen.js. Do not edit manually.',
    '',
  ];

  const commandNames = Object.keys(commands.definitions ?? {});
  commandNames.forEach((name) => {
    lines.push(renderInterface(name, commands.definitions[name]));
    lines.push('');
  });
  if (commandNames.length > 0) {
    lines.push(renderUnion('CommandEnvelope', commandNames));
    lines.push('');
  }

  const eventNames = Object.keys(events.definitions ?? {});
  eventNames.forEach((name) => {
    lines.push(renderInterface(name, events.definitions[name]));
    lines.push('');
  });
  if (eventNames.length > 0) {
    lines.push(renderUnion('EventEnvelope', eventNames));
    lines.push('');
  }

  await fs.mkdir(path.dirname(OUTPUT_TS), { recursive: true });
  await fs.writeFile(OUTPUT_TS, lines.join('\n'), 'utf8');
}

generateTypes().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
